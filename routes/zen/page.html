<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #111827; /* Dark background */
            color: #f9fafb; /* Light text */
            font-family: 'Press Start 2P', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 95%;
            max-width: 1200px; /* Responsive max width */
            padding: 1.25rem;
            border-radius: 0.75rem; /* Rounded corners */
            /*background-color: #1F2937; !* Darker container background *!*/
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); /* Subtle shadow */
            box-sizing: border-box;
            margin-bottom: 2rem;
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 2rem; /* Larger heading */
            color: #6366f1; /* Vibrant purple */
            text-shadow: 0 0 0.25rem rgba(100, 116, 139, 0.8);
        }
        @media (max-width: 400px){
           h1{
             font-size: 1.75rem
           }
        }

        #score-level {
            margin-bottom: 1rem;
            font-size: 1rem;
            color: #cbd5e0;
        }

        #canvas {
          /* background-color: #374151; !* Dark grey canvas background *!*/
            border: 0.25rem solid #4b5563; /* Darker border */
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 1rem;
            width: 100%; /* Responsive width */
            max-width: 320px; /* Max width for the canvas */
            height: auto;
            aspect-ratio: 1 / 2;
        }
       @media (max-width: 400px){
          #canvas{
             max-width: 95%;
          }
       }

        .button {
            padding: 0.75rem 1.5rem;
            margin: 0.5rem;
            border: none;
            border-radius: 0.5rem;
            background-color: #4caf50; /* Green */
            color: white;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s ease, transform 0.2s ease;
            font-family: 'Press Start 2P', monospace;
        }

        .button:hover {
            background-color: #45a049; /* Darker green */
            transform: translateY(-0.125rem); /* Slight lift on hover */
        }
        .button.secondary{
          background-color: #6b7280; /* Gray */
        }
       .button.secondary:hover {
            background-color: #4b5563; /* Darker gray */
        }

        #menu-container {
            position: absolute; /* Overlay the entire screen */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Dark semi-transparent overlay */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #menu-content {
            background-color: #242424; /* Dark menu background */
            padding: 2rem;
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            box-sizing: border-box;
        }

        #menu-content h2 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            color: #f5f5f5;
        }

        #menu-content ul {
            list-style: none;
            padding: 0;
            margin-bottom: 1rem;
        }

        #menu-content li {
            margin-bottom: 0.75rem;
            font-size: 1rem;
            color: #d1d5db;
        }
         #menu-content li span{
            color: #fff;
         }

        #message-box {
            position: absolute;
            bottom: 2rem;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .show-message {
            opacity: 1;
        }
       .settings-group {
          margin-bottom: 1rem;
          text-align: left;
          width: 100%;
       }
      .settings-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        color: #cbd5e0;
      }
      .settings-group input[type="range"],
      .settings-group select {
        width: 100%;
        padding: 0.5rem;
        border-radius: 0.375rem;
        border: 1px solid #4b5563;
        background-color: #374151;
        color: #f9fafb;
        font-size: 0.875rem;
        box-sizing: border-box;
      }
      .settings-group select{
         appearance: none; /* Remove default arrow */
         background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 011.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z' clip-rule='evenodd' /%3E%3C/svg%3E"); /* Custom arrow */
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1rem;
      }
      .settings-group select:focus {
        outline: none;
        border-color: #6366f1; /* Highlight on focus */
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2); /* Focus shadow */
      }
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        background: transparent;
        cursor: pointer;
        width: 100%;
      }
      input[type="range"]:focus {
        outline: none;
      }
      input[type="range"]::-webkit-slider-runnable-track {
        background: #374151;
        border-radius: 0.5rem;
        height: 0.5rem;
        cursor: pointer;
      }
       input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          height: 1.25rem;
          width: 1.25rem;
          background: #6366f1;
          border-radius: 50%;
          border: 2px solid #fff;
          margin-top: -0.375rem;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
       input[type="range"]::-webkit-slider-thumb:hover,
        input[type="range"]::-webkit-slider-thumb:active {
          transform: scale(1.1);
        }
        /* Firefox styles */
        input[type="range"]::-moz-range-track {
            background: #374151;
            border-radius: 0.5rem;
            height: 0.5rem;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            height: 1.25rem;
            width: 1.25rem;
            background: #6366f1;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb:hover,
        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.1);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #game-container {
                width: 98%;
            }
            #menu-content {
                width: 95%;
            }
            .button {
                font-size: 0.9rem;
                padding: 0.75rem 1rem;
            }
            h1 {
                font-size: 1.75rem;
            }
            #score-level{
              font-size: 0.875rem;
            }
        }

        @media (max-width: 480px) {
            .button {
                font-size: 0.8rem;
                padding: 0.5rem 1rem;
            }
             h1{
                font-size: 1.5rem;
             }
              #score-level{
                font-size: 0.75rem;
              }
            #menu-content {
                padding: 1.5rem;
            }
            #menu-content h2 {
                font-size: 1.25rem;
            }
            #menu-content li {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Tetris</h1>
        <p id="score-level">Score: <span>0</span> | Level: <span>1</span></p>
        <canvas id="canvas"></canvas>

        <button id="start-pause-button" class="button">Start</button>
        <button id="settings-button" class="button secondary">Settings</button>
        <button id="menu-button" class="button secondary">Menu</button>

        <div id="message-box"></div>

        <div id="menu-container" style="display: none;">
            <div id="menu-content">
                <h2 id="menu-title">Menu</h2>
                <ul id="main-menu">
                    <li data-action="resume">Resume</li>
                    <li data-action="restart">Restart</li>
                    <li data-action="settings">Settings</li>
                    <li data-action="menu">Main Menu</li>
                </ul>
                 <ul id="settings-menu" style="display: none;">
                    <li data-action="difficulty">Difficulty: <span>Medium</span></li>
                    <li data-action="sound">Sound: <span>On</span></li>
                    <li data-action="back">Back</li>
                </ul>
                <ul id="pause-menu" style="display: none;">
                    <li data-action="resume">Resume</li>
                    <li data-action="restart">Restart</li>
                    <li data-action="settings">Settings</li>
                    <li data-action="menu">Main Menu</li>
                </ul>
                <ul id="gameover-menu" style="display: none;">
                    <li data-action="restart">Restart</li>
                    <li data-action="menu">Main Menu</li>
                </ul>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
    <script>
        // Initialize canvas and context
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreLevelDisplay = document.getElementById('score-level');
        const startPauseButton = document.getElementById('start-pause-button');
        const settingsButton = document.getElementById('settings-button');
        const menuButton = document.getElementById('menu-button');
        const menuContainer = document.getElementById('menu-container');
        const menuContent = document.getElementById('menu-content');
        const mainMenu = document.getElementById('main-menu');
        const settingsMenu = document.getElementById('settings-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const gameOverMenu = document.getElementById('gameover-menu');
        const menuTitle = document.getElementById('menu-title');
        const messageBox = document.getElementById('message-box');

        // Game variables
        let gridSize = 32; // Size of each grid cell
        let gridWidth = 10;  // Width of the grid in cells (fixed)
        let gridHeight = 20; // Height of the grid in cells (fixed)
        let gameGrid = createEmptyGrid(); // 2D array representing the game board
        let currentTetromino = null; // Current tetromino object
        let tetrominoX, tetrominoY;    // Current position of the tetromino
        let score = 0;          // Player's score
        let level = 1;          // Game level
        let gameSpeed = 750;    // Initial game speed in milliseconds (interval between frames)
        const fastDropSpeed = 50; // Speed when down arrow is pressed
        let dropInterval = gameSpeed; // Current drop interval
        let isPaused = true;       // Game pause state
        let isGameOver = false;
        let soundEnabled = true;
        let difficulty = 'medium';  // easy, medium, hard - affects game speed
        let gameLoopInterval;    // Stores the interval ID for the game loop
        let isFastDropping = false;

        // Tetromino shapes and colors
        const tetrominoShapes = [
            // I-shape
            [[1, 1, 1, 1]],

            // J-shape
            [[1, 0, 0],
             [1, 1, 1]],

            // L-shape
            [[0, 0, 1],
             [1, 1, 1]],

            // O-shape
            [[1, 1],
             [1, 1]],

            // S-shape
            [[0, 1, 1],
             [1, 1, 0]],

            // T-shape
            [[0, 1, 0],
             [1, 1, 1]],

            // Z-shape
            [[1, 1, 0],
             [0, 1, 1]]
        ];

        const tetrominoColors = [
            'cyan', 'blue', 'orange', 'yellow', 'lime', 'purple', 'red'
        ];

       /**
         * Creates an empty game grid (10x20 filled with 0s).
         * @returns {Array<Array<number>>} A 2D array representing the game grid.
         */
        function createEmptyGrid() {
            return Array.from({ length: gridHeight }, () => Array(gridWidth).fill(0));
        }

        /**
         * Generates a random integer within a specified range
         * @param {number} min The minimum value of the range (inclusive)
         * @param {number} max The maximum value of the range (inclusive)
         * @returns {number} A random integer between min and max
         */
        function randomInteger(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Spawns a new tetromino at the top of the grid.
         * @returns {object} An object containing the shape, color, and starting position of the tetromino.  Returns null if game over.
         */
        function spawnTetromino() {
            const shapeIndex = randomInteger(0, tetrominoShapes.length - 1);
            const color = tetrominoColors[shapeIndex];
            const shape = tetrominoShapes[shapeIndex];
            const x = Math.floor(gridWidth / 2) - Math.ceil(shape[0].length / 2); // Center tetromino
            const y = 0;

             // Check for game over: can the new tetromino be placed?
            if (isTetrominoAtValidPosition(shape, x, y)) {
                return { shape, color, x, y };
            } else {
                return null; // Game over
            }
        }

        /**
         * Draws a tetromino on the grid.
         * @param {Array<Array<number>>} shape The shape of the tetromino (2D array).
         * @param {string} color The color of the tetromino.
         * @param {number} x The x-coordinate of the tetromino's position.
         * @param {number} y The y-coordinate of the tetromino's position.
         */
        function drawTetromino(shape, color, x, y) {
            shape.forEach((row, rowIndex) => {
                row.forEach((cell, cellIndex) => {
                    if (cell) {
                        drawGridSquare(x + cellIndex, y + rowIndex, color);
                    }
                });
            });
        }

        /**
         * Draws a square on the grid.
         * @param {number} x The x-coordinate of the square.
         * @param {number} y The y-coordinate of the square.
         * @param {string} color The color of the square.
         */
        function drawGridSquare(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
            ctx.strokeStyle = '#374151'; // Darker border color
            ctx.lineWidth = 2;
            ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
        }

        /**
         * Draws the entire game grid.
         */
        function drawGameGrid() {
            gameGrid.forEach((row, rowIndex) => {
                row.forEach((cell, cellIndex) => {
                    if (cell) {
                        drawGridSquare(cellIndex, rowIndex, cell);
                    }
                });
            });
        }

        /**
         * Checks if the tetromino can move to a new position.
         * @param {Array<Array<number>>} shape The shape of the tetromino.
         * @param {number} newX The new x-coordinate.
         * @param {number} newY The new y-coordinate.
         * @returns {boolean} True if the position is valid, false otherwise.
         */
        function isTetrominoAtValidPosition(shape, newX, newY) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const x = newX + col;
                        const y = newY + row;

                        if (x < 0 || x >= gridWidth || y >= gridHeight || gameGrid[y]?.[x]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        /**
         * Moves the tetromino down by one cell.
         */
        function moveTetrominoDown() {
            if (isPaused || isGameOver) return;

            if (isTetrominoAtValidPosition(currentTetromino.shape, tetrominoX, tetrominoY + 1)) {
                tetrominoY++;
            } else {
                lockTetromino();
                clearLines();

                // Spawn the new tetromino.  If null, game over.
                currentTetromino = spawnTetromino();
                if (!currentTetromino) {
                    gameOver(); // Game over if new tetromino can't be placed
                    return;
                }
                tetrominoX = currentTetromino.x;
                tetrominoY = currentTetromino.y;
                dropInterval = gameSpeed; // Reset drop interval
                isFastDropping = false;
            }
        }

        /**
         * Moves the tetromino left by one cell.
         */
        function moveTetrominoLeft() {
            if (isPaused) return;
            if (isTetrominoAtValidPosition(currentTetromino.shape, tetrominoX - 1, tetrominoY)) {
                tetrominoX--;
            }
        }

        /**
         * Moves the tetromino right by one cell.
         */
        function moveTetrominoRight() {
            if (isPaused) return;
            if (isTetrominoAtValidPosition(currentTetromino.shape, tetrominoX + 1, tetrominoY)) {
                tetrominoX++;
            }
        }

       /**
         * Rotates the tetromino clockwise.
         */
        function rotateTetromino() {
            if (isPaused) return;
            const rotatedShape = rotateShape(currentTetromino.shape);
            if (isTetrominoAtValidPosition(rotatedShape, tetrominoX, tetrominoY)) {
                currentTetromino.shape = rotatedShape;
            }
        }

        /**
         * Rotates a shape matrix 90 degrees clockwise.
         * @param {Array<Array<number>>} shape The shape matrix to rotate.
         * @returns {Array<Array<number>>} The rotated shape matrix.
         */
        function rotateShape(shape) {
            const rows = shape.length;
            const cols = shape[0].length;
            const rotatedShape = Array.from({ length: cols }, () => Array(rows).fill(0));

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    rotatedShape[x][rows - 1 - y] = shape[y][x];
                }
            }
            return rotatedShape;
        }

        /**
         * Locks the tetromino in place on the grid.
         */
        function lockTetromino() {
            currentTetromino.shape.forEach((row, rowIndex) => {
                row.forEach((cell, cellIndex) => {
                    if (cell) {
                        gameGrid[tetrominoY + rowIndex][tetrominoX + cellIndex] = currentTetromino.color;
                    }
                });
            });
        }

        /**
         * Clears completed lines from the grid and updates the score.
         */
        function clearLines() {
            let linesCleared = 0;
            for (let y = gridHeight - 1; y >= 0; y--) {
                if (gameGrid[y].every(cell => cell)) {
                    linesCleared++;
                    // Remove the completed line and add a new empty line at the top
                    gameGrid.splice(y, 1);
                    gameGrid.unshift(Array(gridWidth).fill(0));
                }
            }

            if (linesCleared > 0) {
                updateScore(linesCleared);
                playSound('clearLine');
            }
        }

        /**
         * Updates the player's score and level.
         * @param {number} linesCleared The number of lines cleared.
         */
        function updateScore(linesCleared) {
            score += linesCleared * 100 * level; // Score multiplier by level
            scoreLevelDisplay.textContent = `Score: ${score} | Level: ${level}`;

            const levelThreshold = level * 500; // Increase levelevery 500 points * level
            if (score >= levelThreshold) {
                level++;
                gameSpeed = Math.max(100, gameSpeed - 50); // Increase speed, but not too fast
                clearInterval(gameLoopInterval);
                dropInterval = gameSpeed;
                startGameLoop();
                scoreLevelDisplay.textContent = `Score: ${score} | Level: ${level}`;
                playSound('levelUp');
            }
        }

        /**
         * Displays a message to the player.
         * @param {string} message The message to display.
         */
        function showMessage(message) {
            messageBox.textContent = message;
            messageBox.classList.add('show-message');
            setTimeout(() => {
                messageBox.classList.remove('show-message');
            }, 3000); // Hide message after 3 seconds
        }

        /**
         * Game over sequence.  Stops the game and displays the game over menu.
         */
        function gameOver() {
            isGameOver = true;
            isPaused = true;
            clearInterval(gameLoopInterval);
            menuTitle.textContent = "Game Over!";
            showMenu(gameOverMenu);
            playSound('gameOver');
        }

        // Sound effects using Tone.js
        const pieceLandedSound = new Tone.Synth().toDestination();
        pieceLandedSound.oscillator.type = 'triangle';
        const clearLineSound = new Tone.Synth().toDestination();
        clearLineSound.oscillator.type = 'sawtooth';
        const gameOverSound = new Tone.Synth().toDestination();
        gameOverSound.oscillator.type = 'square';
        const buttonClickSound = new Tone.Synth().toDestination();
        buttonClickSound.oscillator.type = 'sine';
        const levelUpSound = new Tone.Synth().toDestination();
        levelUpSound.oscillator.type = 'sine';

        /**
         * Plays a sound effect.
         * @param {string} type The type of sound effect to play ('pieceLanded', 'clearLine', 'gameOver', 'buttonClick', 'levelUp').
         */
        function playSound(type) {
            if (!soundEnabled) return;
            switch (type) {
                case 'pieceLanded':
                    pieceLandedSound.triggerAttackRelease('C5', '8n');
                    break;
                case 'clearLine':
                    clearLineSound.triggerAttackRelease('G4', '4n');
                    break;
                 case 'gameOver':
                    const polySynth = new Tone.PolySynth(Tone.Synth).toDestination();
                    polySynth.triggerAttackRelease(["C2", "E2", "G2", "Bb2"], "2n");
                    break;
                case 'buttonClick':
                    buttonClickSound.triggerAttackRelease('C6', '16n');
                    break;
                case 'levelUp':
                    levelUpSound.triggerAttackRelease('C6', '8n');
                    break;
            }
        }

        // --- Event Handlers ---

        /**
         * Handles the start/pause button click.
         */
        function handleStartPauseClick() {
          playSound('buttonClick');
            if (isGameOver) {
                startGame(); // Restart the game
                isGameOver = false;
            } else if (isPaused) {
                if (currentTetromino === null) {
                    startGame();
                } else {
                    isPaused = false;
                    startPauseButton.textContent = 'Pause';
                    startGameLoop();
                    hideMenu();
                }

            } else {
                isPaused = true;
                startPauseButton.textContent = 'Resume';
                clearInterval(gameLoopInterval);
                showMenu(pauseMenu);
            }
        }

        /**
         * Handles the settings button click.
         */
        function handleSettingsClick() {
            playSound('buttonClick');
            showMenu(settingsMenu);
            menuTitle.textContent = "Settings";
        }

        /**
         * Handles the menu button click.
         */
        function handleMenuClick() {
          playSound('buttonClick');
          showMenu(mainMenu);
          menuTitle.textContent = "Menu";
        }

        /**
         * Handles keydown events (arrow keys for movement, P for pause).
         */
      function handleKeyDown(event) {
          switch (event.key) {
            case 'ArrowLeft':
              moveTetrominoLeft();
              break;
            case 'ArrowRight':
              moveTetrominoRight();
              break;
            case 'ArrowDown':
              if (!isFastDropping) {
                isFastDropping = true;
                clearInterval(gameLoopInterval);
                dropInterval = fastDropSpeed;
                startGameLoop(); // Start the game loop with new interval
              }
              break;
            case 'ArrowUp':
              rotateTetromino();
              break;
            case 'p': // Pause on 'p' key
            case 'P':
              handleStartPauseClick(); // Reuse start/pause logic
              break;
          }
          if (!isPaused && !isGameOver) {
            // PreventDefault for arrow keys to avoid scrolling
            if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp'].includes(event.key)) {
                event.preventDefault();
            }
          }
        }

        /**
         * Handles keyup events
         */
        function handleKeyUp(event) {
           if (event.key === 'ArrowDown') {
              isFastDropping = false; // Reset fast dropping flag
              clearInterval(gameLoopInterval);
              dropInterval = gameSpeed;
              startGameLoop();
           }
        }

        /**
         * Handles menu item clicks.
         */
        function handleMenuItemClick(event) {
            playSound('buttonClick');
            const action = event.target.dataset.action;
            switch (action) {
                case 'resume':
                    isPaused = false;
                    startPauseButton.textContent = 'Pause';
                    startGameLoop();
                    hideMenu();
                    break;
                case 'restart':
                    startGame();
                    break;
                case 'settings':
                    showMenu(settingsMenu);
                    menuTitle.textContent = "Settings";
                    break;
                case 'menu':
                    showMenu(mainMenu);
                    menuTitle.textContent = "Menu";
                    break;
                case 'back':
                    showMenu(mainMenu);
                    menuTitle.textContent = "Menu";
                    break;
                case 'difficulty':
                    const difficulties = ['easy', 'medium', 'hard'];
                    const currentDifficultyIndex = difficulties.indexOf(difficulty);
                    const nextDifficultyIndex = (currentDifficultyIndex + 1) % difficulties.length;
                    difficulty = difficulties[nextDifficultyIndex];
                     let newSpeed;
                    switch(difficulty){
                       case 'easy':
                         newSpeed = 1000;
                         break;
                       case 'medium':
                         newSpeed = 750;
                         break;
                       case 'hard':
                         newSpeed = 500;
                         break;
                    }
                    gameSpeed = newSpeed;
                    if(!isPaused){
                       clearInterval(gameLoopInterval);
                       dropInterval = gameSpeed;
                       startGameLoop();
                    }

                    event.target.textContent = `Difficulty: ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`;
                    break;
                 case 'sound':
                    soundEnabled = !soundEnabled;
                    event.target.textContent = `Sound: ${soundEnabled ? 'On' : 'Off'}`;
                    break;
            }
        }

        /**
         * Shows a menu.
         * @param {HTMLElement} menu The menu element to show.
         */
        function showMenu(menu) {
            menuContainer.style.display = 'flex';
            // Hide all menus first
            [mainMenu, settingsMenu, pauseMenu, gameOverMenu].forEach(m => m.style.display = 'none');
            menu.style.display = 'block'; // Show the selected menu
            isPaused = true; // Pause the game when menu is open
            clearInterval(gameLoopInterval);
            startPauseButton.textContent = "Resume"; // update button text
        }

        /**
         * Hides the menu.
         */
        function hideMenu() {
            menuContainer.style.display = 'none';
        }

        // --- Game Functions ---

        /**
         * Initializes the game, resets variables, and starts the game loop.
         */
        function startGame() {
            gameGrid = createEmptyGrid();
            score = 0;
            level = 1;
            gameSpeed = 750;
            dropInterval = gameSpeed; // Reset drop interval
            isFastDropping = false;
            scoreLevelDisplay.textContent = `Score: ${score} | Level: ${level}`;
            isPaused = false;
            isGameOver = false;
            startPauseButton.textContent = 'Pause';
            clearInterval(gameLoopInterval); // Clear any existing interval
            currentTetromino = spawnTetromino();
            if(!currentTetromino){
               gameOver();
               return;
            }
            tetrominoX = currentTetromino.x;
            tetrominoY = currentTetromino.y;
            hideMenu();
            startGameLoop();
        }

        /**
         * Starts the game loop with the current drop interval.
         */
        function startGameLoop() {
            clearInterval(gameLoopInterval); // Clear any existing interval
            gameLoopInterval = setInterval(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGameGrid();
                drawTetromino(currentTetromino.shape, currentTetromino.color, tetrominoX, tetrominoY);
                moveTetrominoDown();
            }, dropInterval);
        }

        /**
         * Draws the game grid and the current tetromino on the canvas.
         */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas
            drawGameGrid();
            if (currentTetromino) {
                drawTetromino(currentTetromino.shape, currentTetromino.color, tetrominoX, tetrominoY);
            }
        }

        // --- Initialization ---

        // Set canvas size
        canvas.width = gridWidth * gridSize;
        canvas.height = gridHeight * gridSize;

        // Event listeners
        startPauseButton.addEventListener('click', handleStartPauseClick);
        settingsButton.addEventListener('click', handleSettingsClick);
        menuButton.addEventListener('click', handleMenuClick);
        mainMenu.addEventListener('click', handleMenuItemClick);
        settingsMenu.addEventListener('click', handleMenuItemClick);
        pauseMenu.addEventListener('click', handleMenuItemClick);
        gameOverMenu.addEventListener('click', handleMenuItemClick);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Initial draw
        draw();
        showMenu(mainMenu); // Show main menu on initial load

    </script>
</body>
</html>
